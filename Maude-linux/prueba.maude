load needed .

set clear rules off .
set print attribute on .

mod MODELO is
	pr SAMPLER .
	pr SET{Agent} .
	sort State .
	
	op f : -> Float .
	ops a t n m : -> Nat .
	eq a = 1 .
	eq f = 4.0 .
	eq t = 5 .
	eq n = | AL | .
	eq m = 2 . --- number of edges for barabasi graph
	ops AgentList sol : -> Set{Agent} .

	op AL : -> Set{Agent} .
  eq AL = ag(1, (4 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3)),  ag(4, (4 |-> 4, 1 |-> 1, 2 |-> 2, 3 |-> 2)) .
	ops GRAFO baraGp : -> Graph .
	eq GRAFO = ed(1, 2), ed(1,4), ed(1,3), ed(2,3), ed(2,4) .
	eq baraGp = ed(1, 2), ed(2,4), ed(1,3) .

	--- Represents the state of the model how has change over n itterations
	op < _, _, _ > : Graph Set{Agent} Nat -> State .

	vars G NET G' : Graph .
	vars LA LA' : Set{Agent} .
	var T T' : Set{Nat} .
	vars A A' : Agent .
	vars H I J K L M N : Nat .
	vars E E' : Edge .
	vars B C : Map{Nat, Nat} .
	var O Q R : Float .

--- select a index over a list of index .
	op selectFeature : Set{Nat} Nat -> Nat .
	eq selectFeature((T, N), s(I)) = if s(I) == 1 then N else selectFeature(T, I)  fi .
	eq selectFeature(empty, N) = 0 .
	eq selectFeature(empty,0) = 0 .
	eq selectFeature(T,0) = 0 .

	op selectAgent : Set{Agent} Nat -> Agent .
	eq selectAgent((LA, ag(s(I),B)), s(I)) = selectAgent(LA, I) .
	eq selectAgent((LA, ag(1, B)), 1) =  ag(1, B).

--- calculate which is the probability of two agents to interact
	op proSelect : Agent Agent -> Float .
	ceq proSelect( A, A' ) = countEquals( A, 0.0, A' ) / f  if countEquals( A, 0.0, A' ) > 0.0 .
	eq proSelect(A, A') = 0.0 [owise] .

--- is an auxiliar function that count how many equals features has two agents
  op countEquals : Agent  Float Agent -> Float .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> L), C))) = O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> J), C))) = if threshold(L,J) then O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) else 0.0 + countEquals(ag(N, B), O, ag(M, C)) fi .
	eq countEquals(ag(N, empty), O, ag(M, empty)) = 0.0 .

--- is a boolean oeration that is true if the difference betwen two features of an agent is iqual or less than a.
	op threshold : Nat Nat -> Bool .
	eq threshold(I, J) = if abs(J - I) <= a and abs(J - I) > 0 then true else false fi .

--- is a exchange of an index feature information betwen two agents.
	op changeFeature : Agent Agent Nat -> Agent .
	eq changeFeature(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)), J) =  if  sampleBernoulli(proSelect(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)))) then ag(I, ((J |-> N), B)) else ag(I, ((J |-> L), B)) fi .
	eq changeFeature(A, A', 0) = A  .
	eq changeFeature(A, empty, N) = A .
	
	--- is an auxiliar function that change a random not common feature between two agents
	op auxFeatures : Agent Agent -> Agent .
	eq auxFeatures(A, A') = changeFeature(A, A', selectFeature(availableFeature(A, A'), genRandom(1, | availableFeature(A, A') | ))) .

	--- selects the features that are not common but under the threshold
	op availableFeature : Agent Agent -> Set{Nat} .
	eq availableFeature(ag(I, ((J |-> L), B)), ag(M, ((J |-> N), C))) = if threshold(L, N) then J, availableFeature(ag(I, B), ag(M, C)) else availableFeature(ag(I, B), ag(M, C)) fi .
	eq availableFeature(ag(I, empty), ag(J, empty)) = empty .
	eq availableFeature(A, ag(J, empty)) = empty .

	--- gives an agent that has a index I
	op getAgent : Set{Agent} Nat -> Agent .
	eq getAgent((ag(I, B), LA), I) = ag(I, B)  .

	op selectNeighbor : Set{Agent} Nat -> Agent .
	eq selectNeighbor((ag(J, B), LA), J) = ag(J, B) .
	eq selectNeighbor(LA, 0) = ag(0, empty)  .

	op getRAgent : Set{Agent} -> Set{Agent} .
	eq getRAgent(LA) = getAgent(LA, genRandom(1, n)) .

	op delAgent : Set{Agent} Agent -> Set{Agent} .
	eq delAgent((LA,ag(I, B) ), ag(I, B)) = LA .

	---takes a graph and a list of agents s an agent and from it gets it's neighbors, select one randomly and then gets all posible features and ramdomly select one to exchange value.
	op update : Graph Set{Agent} -> Set{Agent} .
	eq update(G, LA) = auxUpdate(G, LA, getRAgent(LA)) .
	
---
	op auxUpdate : Graph Set{Agent} Agent -> Set{Agent} .
	eq auxUpdate(G, LA, ag(I, B)) = delAgent(LA, ag(I, B)), auxFeatures(ag(I,B), selectNeighbor(LA, selectFeature(getNeighbors(G, I), genRandom(1, | getNeighbors(G, I) |)))) .

	op resultAgents : State -> Set{Agent} .
	eq resultAgents(< G, LA, 0 >) = LA .
	
	op genAgents : Nat Nat Nat -> Set{Agent} .
	ceq genAgents(I, J, K) = ag(I, genFeatures(J, K)), genAgents(I - 1, J, K) if I > 0 .
	eq genAgents(0, J, K) = empty [owise] .
	 
	op genFeatures : Nat Nat -> Map{Nat, Nat} .
	ceq genFeatures(N, J) = N |-> genRandom(1, J), genFeatures(N - 1, J) if N > 0 .
	eq genFeatures(0, J)= empty [owise] . 
	
------------------- Compete O=1 and Erdos Renyi O < 1 ------------------------------------	
	
	op genEAux[_|_|_] : Nat Float Nat  -> Graph .
	ceq genEAux[N | O | J] = if sampleBernoulli(O)  then ed(N,J), genEAux[N | O | J - 1] else genEAux[N | O | J - 1] fi if J > N .
	eq genEAux[N | O | J ] = empty [owise ].
	
	op genGraphs : Nat Float Nat -> Graph .
	ceq genGraphs(N, O, I) = genEAux[N | O | I], genGraphs(N - 1, O, I) if N > 0 .
	eq genGraphs(0, O, I) = empty .
	
	
--------------- Barabasi Albert Model --------------------------------------
	
	op genBAG : Nat Graph Nat Nat -> Graph .
	eq genBAG(N, G, M, K) = genBAG(N + 1, (G, mEdgeAdd(G,nodeEdge(G),N,M,empty)), M, K) [owise].
	ceq genBAG(N,G,M,K) =  G, mEdgeAdd(G,nodeEdge(G),N,M,empty) if N == K . 
	
	--- auxBAG returns posible new edges for the graph based on an initial graph G and a list of Agents ID's T
	op auxBAG : Graph Set{Nat} Nat Nat -> Graph .
	ceq auxBAG(G, (N,T), J, M) = if sampleBernoulli(proBA(G,N)) then ed(N,J), auxBAG(G,T,J,M - 1) else auxBAG(G,T,J,M) fi if M > 0 .
	eq auxBAG(G,T,J,0) = empty .
	eq auxBAG(G,empty,J, 0) = empty .
	eq auxBAG(G,empty,J, M) = empty .
	
	--- gives a graph with M edges for an agent N
	op mEdgeAdd : Graph Set{Nat} Nat Nat Graph -> Graph .
	eq mEdgeAdd(G, T, N, M, G') = if | G' | >= M then pick(G', M) else mEdgeAdd(G, T, N, M, auxBAG(G, T, N, M )) fi .
	eq mEdgeAdd(G, T, N, M, empty) = mEdgeAdd(G, T, N, M, auxBAG(G, T, N, M )) .
	
---------------------Watts-Strogatz Model --------------------------------------
	
	op k : -> Nat . --- node Degree
	eq k = 2 .
	
	op genWSG : Graph Graph Nat Nat -> Graph .
	eq genWSG(G',(G, ed(K,L)), N, I) = if sampleBernoulli((1.0 / (nTf((I - N))))) then genWSG(selectWSG(G',ed(K,L),ed(K, genRandom(1,I)),N),G,N,I) else genWSG(G',G,N,I) fi .
	eq genWSG(G',(empty, ed(K,L)), N, I) = if sampleBernoulli(0.5) then genWSG(selectWSG(G',ed(K,L),ed(K, genRandom(1,I)),N),empty,N,I) else genWSG(G',empty,N,I) fi .
	eq genWSG(G', empty ,N, I) = G'	 .
	

	op selectWSG : Graph Edge Edge Nat -> Graph .
	eq selectWSG(G,ed(I,J),ed(I,K),N) = if  (ed(I,K) in G or K == I) then selectWSG(G,ed(I,J),ed(I,genRandom(1,N)),N) else exchangeWSG(G,ed(I,J),ed(I,K)) fi .
	
	--- elimina el edge E y anade el E' al grafo G
	op exchangeWSG : Graph Edge Edge ->  Graph .
	eq exchangeWSG(G, E, E') = delEdge(G,E), E' .
	
	--- gives the initial state for watts stogatz model
	op auxWSG : Nat Nat Nat -> Graph .
	ceq auxWSG(N, I, J) =  nearWSGB(I,J,N,1), nearWSGF(I,J,N,1,1), auxWSG(N, I - 1, J)  if I > 0 .
	eq auxWSG(N,0,J) = empty .	
	
	op nearWSGB : Nat Nat Nat Nat -> Graph .
	ceq nearWSGB(I, J, N, K) = if I - N / 2 > 0 then ed(I,I - K), nearWSGB(I, J,N - 2,K + 1) else ed(I,J), nearWSGB(I,J - 1, N - 2, K) fi if N > 0 .
	eq nearWSGB(I,J,0, K) = empty .
		
	op nearWSGF : Nat Nat Nat Nat Nat -> Graph .
	ceq nearWSGF(I, J, N, K, L) = if I + K <= J then ed(I,I + K), nearWSGF(I, J,N - 2,K + 1,L) else ed(I,L), nearWSGF(I,L, N - 2,K,L + 1) fi if N > 0 .
	eq nearWSGF(I,J,0,K,L) = empty .
		
 crl [inte] : < G, LA, N >  => < G, update(G, LA), N - 1 > if N > 0 .

endm


---(
rew genWSG(auxWSG(2,15,15),auxWSG(2,15,15),2,15) .


	rew < GRAFO, AL, 2 > .
	rew mEdgeAdd(GRAFO,nodeEdge(GRAFO),5,2,empty) .
	

op rewireEdges : Nat Real -> Graph .
  eq rewireEdges(K, P) = if P <= 0 then empty else rewireAllEdges(P, K) fi .

  op rewireAllEdges : Real Nat -> Graph .
  eq rewireAllEdges(P, K) = if P <= 0 then empty else rewireEdge(P, K) âˆª rewireAllEdges(P - 1, K) fi .

  op rewireEdge : Real Nat -> Graph .
  eq rewireEdge(P, K) = if RandomValue(P) == 1 then rewire(K) else K fi .
 	)
