load needed .

set clear rules off .
set print attribute on .

mod MODELO is
	pr SAMPLER .
---	pr SET{Nat} .
---	pr SET{IndexPair} .
	pr SET{Agent} .
	sort State .

	op f : -> Float .
	ops a t n : -> Nat .
	eq a = 1 .
	eq f = 4.0 .
	eq t = 5 .
	eq n = | AL | .
	ops AgentList sol : -> Set{Agent} .

	op AL : -> Set{Agent} .
  eq AL = ag(1, (4 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3)),  ag(4, (4 |-> 4, 1 |-> 1, 2 |-> 2, 3 |-> 2)) .
	ops GRAFO baraGp : -> Graph .
	eq GRAFO = ed(1, 2), ed(1,4), ed(1,3), ed(2,3), ed(2,4) .
	eq baraGp = ed(1, 2), ed(1,4), ed(1,3) .

	--- Represents the state of the model how has change over n itterations
	op < _, _, _ > : Graph Set{Agent} Nat -> State .

	vars G NET G' : Graph .
	vars LA LA' : Set{Agent} .
	var T T' : Set{Nat} .
	vars A A' : Agent .
	vars H I J K L M N : Nat .
	vars E E' : Edge .
	vars B C : Map{Nat, Nat} .
---	vars T T' : Set{IndexPair} .
---	var P : IndexPair .
	var O : Float .

--- select a index over a list of index .
	op selectFeature : Set{Nat} Nat -> Nat .
	eq selectFeature((T, N), s(I)) = if s(I) == 1 then N else selectFeature(T, I)  fi .
	eq selectFeature(empty, N) = 0 .
	eq selectFeature(empty,0) = 0 .
	eq selectFeature(T,0) = 0 .

	op selectAgent : Set{Agent} Nat -> Agent .
	eq selectAgent((LA, ag(s(I),B)), s(I)) = selectAgent(LA, I) .
	eq selectAgent((LA, ag(1, B)), 1) =  ag(1, B).

--- calculate which is the probability of two agents to interact
	op proSelect : Agent Agent -> Float .
	ceq proSelect( A, A' ) = countEquals( A, 0.0, A' ) / f  if countEquals( A, 0.0, A' ) > 0.0 .
	eq proSelect(A, A') = 0.0 [owise] .

--- is an auxiliar function that count how many equals features has two agents
  op countEquals : Agent  Float Agent -> Float .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> L), C))) = O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> J), C))) = if threshold(L,J) then O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) else 0.0 + countEquals(ag(N, B), O, ag(M, C)) fi .
	eq countEquals(ag(N, empty), O, ag(M, empty)) = 0.0 .

--- is a boolean oeration that is true if the difference betwen two features of an agent is iqual or less than a.
	op threshold : Nat Nat -> Bool .
	eq threshold(I, J) = if abs(J - I) <= a and abs(J - I) > 0 then true else false fi .

--- is a exchange of an index feature information betwen two agents.
	op changeFeature : Agent Agent Nat -> Agent .
	eq changeFeature(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)), J) =  if  sampleBernoulli(proSelect(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)))) then ag(I, ((J |-> N), B)) else ag(I, ((J |-> L), B)) fi .
	eq changeFeature(A, A', 0) = A  .
	eq changeFeature(A, empty, N) = A .

	--- selects the features that are not common but under the threshold
	op availableFeature : Agent Agent -> Set{Nat} .
	eq availableFeature(ag(I, ((J |-> L), B)), ag(M, ((J |-> N), C))) = if threshold(L, N) then J, availableFeature(ag(I, B), ag(M, C)) else availableFeature(ag(I, B), ag(M, C)) fi .
	eq availableFeature(ag(I, empty), ag(J, empty)) = empty .
	eq availableFeature(A, ag(J, empty)) = empty .


	--- gives an agent that has a index I
	op getAgent : Set{Agent} Nat -> Agent .
	eq getAgent((ag(I, B), LA), I) = ag(I, B)  .

	op selectNeighbor : Set{Agent} Nat -> Agent .
	eq selectNeighbor((ag(J, B), LA), J) = ag(J, B) .
	eq selectNeighbor(LA, 0) = ag(0, empty)  .

	op getRAgent : Set{Agent} -> Set{Agent} .
	eq getRAgent(LA) = getAgent(LA, genRandom(1, n)) .

	op delAgent : Set{Agent} Agent -> Set{Agent} .
	eq delAgent((LA,ag(I, B) ), ag(I, B)) = LA .

	--- gives the neighbors of an agent with index I.
	op getNeighbors : Graph Nat -> Set{Nat} .
	eq getNeighbors((ed(J, I), G) , J) = I , getNeighbors(G, J) .
	eq getNeighbors((ed(J, I), G) , I) = J , getNeighbors(G, I) .
	eq getNeighbors((ed(J, I), empty) , J) = I .
	eq getNeighbors((ed(J, I), empty) , I) = J .
	eq getNeighbors(G, I) = empty [owise].



	---takes a graph and a list of agents s an agent and from it gets it's neighbors, select one randomly and then gets all posible features and ramdomly select one to exchange value.
	op update : Graph Set{Agent} -> Set{Agent} .
	eq update(G, LA) = auxUpdate(G, LA, getRAgent(LA)) .


---
	op auxUpdate : Graph Set{Agent} Agent -> Set{Agent} .
	eq auxUpdate(G, LA, ag(I, B)) = delAgent(LA, ag(I, B)), auxFeatures(ag(I,B), selectNeighbor(LA, selectFeature(getNeighbors(G, I), genRandom(1, | getNeighbors(G, I) |)))) .

--- is an auxiliar function that change a random not common feature between two agents
	op auxFeatures : Agent Agent -> Agent .
	eq auxFeatures(A, A') = changeFeature(A, A', selectFeature(availableFeature(A, A'), genRandom(1, | availableFeature(A, A') | ))) .

	var R : Int .
	op checkLeng : Int -> Nat .
	eq checkLeng(R)= if 0 > R then 0 else R fi .

	op resultAgents : State -> Set{Agent} .
	eq resultAgents(< G, LA, 0 >) = LA .
	
	op genAgents : Nat Nat Nat -> Set{Agent} .
	ceq genAgents(I, J, K) = ag(I, genFeatures(J, K)), genAgents(I - 1, J, K) if I > 0 .
	eq genAgents(0, J, K) = empty [owise] .
	 
	op genFeatures : Nat Nat -> Map{Nat, Nat} .
	ceq genFeatures(N, J) = N |-> genRandom(1, J), genFeatures(N - 1, J) if N > 0 .
	eq genFeatures(0, J)= empty [owise] . 
	
	op genEAux[_|_|_] : Nat Float Nat  -> Graph .
	ceq genEAux[N | O | J] = if sampleBernoulli(O)  then ed(N,J), genEAux[N | O | J - 1] else genEAux[N | O | J - 1] fi if J > N .
	eq genEAux[N | O | J ] = empty [owise ].
	
	op genGraphs : Nat Float Nat -> Graph .
	ceq genGraphs(N, O, I) = genEAux[N | O | I], genGraphs(N - 1, O, I) if N > 0 .
	eq genGraphs(0, O, I) = empty .
	
	op genBAG : Nat Graph Float -> Graph .
	eq genBAG(N, (ed(I, J),G), O) = if sampleBernoulli(proBA(G, N)) then  G, genBAG(N - 1, G , O) else G fi .
	eq genBAG(0, G, O) = empty [owise] . 
	
	op auxBAG : Graph Set{Nat} Nat -> Graph .
	eq auxBAG(G, (N,T), J) = if sampleBernoulli(proBA(G,N)) then ed(N,J), auxBAG(G,T,J) else auxBAG(G,T,J) fi .
	
	--- list all existing Agents Id with an edge 
	op nodeEdge : Graph -> Set{Nat} .
	eq nodeEdge((ed(N,J),G)) = N, J, nodeEdge(G) .
	eq nodeEdge((ed(N,J), empty)) = N, J [owise] .
	 
	op proBA : Graph Nat -> Float .
	eq proBA(G, N) = nodeDegre(G,N) / allNDegre(G,1) .
	
	op countFloat : Set{Nat} -> Float .
	eq countFloat((N, T)) = 1.0 + countFloat(T) .
	eq countFloat(empty) = 0.0 .
	
	op nodeDegre : Graph Nat -> Float .
	eq nodeDegre((ed(N,I),G),N) = 1.0 + nodeDegre(G,N) .
	eq nodeDegre((ed(J,I),G),N) = nodeDegre(G,N) .
	eq nodeDegre((ed(N,I),empty), N) = 1.0 .
	eq nodeDegre((ed(J,I),(empty).Graph), N) = 0.0 .
	
	op allNDegre : Graph Nat -> Float .
	eq allNDegre(G,N) = if N on G then nodeDegre(G,N) + allNDegre(G,N + 1) else 0.0 fi .
		
	
	
	
		
 crl [inte] : < G, LA, N >  => < G, update(G, LA), N - 1 > if N > 0 .

endm


---(
	rew < GRAFO, AL, 2 > .
 	rew availableFeature(ag(0, (0 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(1, (0 |-> 3, 1 |-> 3, 2 |-> 4, 3 |-> 1))) .
	rew getNeighbors(GRAFO, 0) .
	rew getAgent((ag(0, (0 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(1, (0 |-> 3, 1 |-> 3, 2 |-> 4, 3 |-> 1)), ag(2, (0 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3))), (1, 2)) .
	rew selectFeature(getNeighbors(GRAFO, 4), genRandom(1, | getNeighbors(GRAFO, 4) |)) .

	rew selectFeature(availableFeature(ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3))), genRandom(1, | availableFeature(ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3)))  | )) .
