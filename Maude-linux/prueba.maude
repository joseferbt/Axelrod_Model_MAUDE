load graphs .

set clear rules off .
set print attribute on .

mod MODELO is
	pr SAMPLER .
---	pr SET{Nat} .
---	pr SET{IndexPair} .
	pr SET{Agent} .
	sort State .

	op f : -> Float .
	ops a t n : -> Nat .
	eq a = 1 .
	eq f = 4.0 .
	eq t = 5 .
	eq n = | AL | .
	ops AgentList sol : -> Set{Agent} .

	op AL : -> Set{Agent} .
  eq AL = ag(1, (4 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3)),  ag(4, (4 |-> 4, 1 |-> 1, 2 |-> 2, 3 |-> 2)) .
	op GRAFO : -> Graph .
	eq GRAFO = ed(1, (4, 2, 3)), ed(4, (1, 2, 3)), ed(3, (4, 1, 2)), ed(2, (4, 1, 3)) .

	--- Represents the state of the model how has change over n itterations
	op < _, _, _ > : Graph Set{Agent} Nat -> State .

	vars G NET G' : Graph .
	vars LA LA' : Set{Agent} .
	var T T' : Set{Nat} .
	vars A A' : Agent .
	vars H I J K L M N : Nat .
	vars E E' : Edge .
	vars B C : Map{Nat, Nat} .
---	vars T T' : Set{IndexPair} .
---	var P : IndexPair .
	var O : Float .

--- select a index over a list of index .
	op selectFeature : Set{Nat} Nat -> Nat .
	eq selectFeature((T, N), s(I)) = if s(I) == 1 then N else selectFeature(T, I)  fi .
	eq selectFeature(empty, N) = 0 .
	eq selectFeature(empty,0) = 0 .
	eq selectFeature(T,0) = 0 .

	op selectAgent : Set{Agent} Nat -> Agent .
	eq selectAgent((LA, ag(s(I),B)), s(I)) = selectAgent(LA, I) .
	eq selectAgent((LA, ag(1, B)), 1) =  ag(1, B).

--- calculate which is the probability of two agents to interact
	op proSelect : Agent Agent -> Float .
	ceq proSelect( A, A' ) = countEquals( A, 0.0, A' ) / f  if countEquals( A, 0.0, A' ) > 0.0 .
	eq proSelect(A, A') = 0.0 [owise] .

--- is an auxiliar function that count how many equals features has two agents
  op countEquals : Agent  Float Agent -> Float .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> L), C))) = O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) .
	eq countEquals(ag(N, ((I |-> L), B)), O, ag(M, ((I |-> J), C))) = if threshold(L,J) then O + 1.0 + countEquals(ag(N, B), O, ag(M, C)) else 0.0 + countEquals(ag(N, B), O, ag(M, C)) fi .
	eq countEquals(ag(N, empty), O, ag(M, empty)) = 0.0 .

--- is a boolean oeration that is true if the difference betwen two features of an agent is iqual or less than a.
	op threshold : Nat Nat -> Bool .
	eq threshold(I, J) = if abs(J - I) <= a and abs(J - I) > 0 then true else false fi .

--- is a exchange of an index feature information betwen two agents.
	op changeFeature : Agent Agent Nat -> Agent .
	eq changeFeature(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)), J) =  if  sampleBernoulli(proSelect(ag(I, ((J |-> L), B)), ag(K, ((J |-> N), C)))) then ag(I, ((J |-> N), B)) else ag(I, ((J |-> L), B)) fi .
	eq changeFeature(A, A', 0) = A  .
	eq changeFeature(A, empty, N) = A .

	--- selects the features that are not common but under the threshold
	op availableFeature : Agent Agent -> Set{Nat} .
	eq availableFeature(ag(I, ((J |-> L), B)), ag(M, ((J |-> N), C))) = if threshold(L, N) then J, availableFeature(ag(I, B), ag(M, C)) else availableFeature(ag(I, B), ag(M, C)) fi .
	eq availableFeature(ag(I, empty), ag(J, empty)) = empty .
	eq availableFeature(A, ag(J, empty)) = empty .


	--- gives an agent that has a index I
	op getAgent : Set{Agent} Nat -> Agent .
	eq getAgent((ag(I, B), LA), I) = ag(I, B)  .

	op selectNeighbor : Set{Agent} Nat -> Agent .
	eq selectNeighbor((ag(J, B), LA), J) = ag(J, B) .
	eq selectNeighbor(LA, 0) = ag(0, empty)  .

	op getRAgent : Set{Agent} -> Set{Agent} .
	eq getRAgent(LA) = getAgent(LA, genRandom(1, n)) .

	op delAgent : Set{Agent} Agent -> Set{Agent} .
	eq delAgent((LA,ag(I, B) ), ag(I, B)) = LA .

	--- gives the neighbors of an agent with index I.
	op getNeighbors : Graph Nat -> Set{Nat} .
	eq getNeighbors((ed(J, T), G) , J) = T .
	eq getNeighbors(G, 0) = empty .


	---takes a graph and a list of agents s an agent and from it gets it's neighbors, select one randomly and then gets all posible features and ramdomly select one to exchange value.
	op update : Graph Set{Agent} -> Set{Agent} .
	eq update(G, LA) = auxUpdate(G, LA, getRAgent(LA)) .


---
	op auxUpdate : Graph Set{Agent} Agent -> Set{Agent} .
	eq auxUpdate(G, LA, ag(I, B)) = delAgent(LA, ag(I, B)), auxFeatures(ag(I,B), selectNeighbor(LA, selectFeature(getNeighbors(G, I), genRandom(1, | getNeighbors(G, I) |)))) .

--- is an auxiliar function that change a random not common feature between two agents
	op auxFeatures : Agent Agent -> Agent .
	eq auxFeatures(A, A') = changeFeature(A, A', selectFeature(availableFeature(A, A'), genRandom(1, | availableFeature(A, A') | ))).

	var R : Int .
	op checkLeng : Int -> Nat .
	eq checkLeng(R)= if 0 > R then 0 else R fi .

	op resultAgents : State -> Set{Agent} .
	eq resultAgents(< G, LA, 0 >) = LA .

 crl [inte] : < G, LA, N >  => < G, update(G, LA), N - 1 > if N > 0 .

endm


---(
	rew < GRAFO, AL, 2 > .
 	rew availableFeature(ag(0, (0 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(1, (0 |-> 3, 1 |-> 3, 2 |-> 4, 3 |-> 1))) .
	rew getNeighbors(GRAFO, 0) .
	rew getAgent((ag(0, (0 |-> 1, 1 |-> 2, 2 |-> 3, 3 |-> 4)), ag(1, (0 |-> 3, 1 |-> 3, 2 |-> 4, 3 |-> 1)), ag(2, (0 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3))), (1, 2)) .
	rew selectFeature(getNeighbors(GRAFO, 4), genRandom(1, | getNeighbors(GRAFO, 4) |)) .

	rew selectFeature(availableFeature(ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3))), genRandom(1, | availableFeature(ag(2, (4 |-> 3, 1 |-> 4, 2 |-> 4, 3 |-> 1)), ag(3, (4 |-> 2, 1 |-> 3, 2 |-> 1, 3 |-> 3)))  | )) .
