load sampler .

fmod NEEDED-SORT is
	pr SET{Nat} .
	pr MAP{Nat, Nat} .
	inc NAT .
  	inc INT .
  	inc FLOAT .

	sort Agent .
  	sort Graph .
  	sort Edge .
  	subsort Nat < Edge < Graph .

	op ed : Nat Nat -> Edge [ctor assoc comm].
	op empty : -> Graph [ctor].
	op _, _ : Graph Graph -> Graph [ctor assoc comm id: empty prec 121 format (d r os d)] .
	op ag : Nat Map{Nat, Nat} -> Agent [ctor] .
	
	var E : Edge .
	var G : Graph .
	vars N I K J : Nat . 
	var O : Float .
	var T : Set{Nat}.
	
	op _on_ : Nat Graph -> Bool .
	eq N on (ed(N, J), G) = true .
	eq N on (ed(N, J)) = true .
	eq N on G = false [owise] .
	
	op _in_ : Edge Graph -> Bool .
	eq ed(I, J) in (ed(I, J), G) = true .
	eq ed(I, J) in ed(I, J) = true .
	eq  ed(I, J) in G = false [owise] .
	
	op |_| : Graph -> Nat .
	eq | (ed(I,J),G) | = 1 + | G | .
	eq | ed(I,J),empty | = 1 .	 
	
	op pick : Graph Nat -> Graph .
	ceq pick((ed(N,J),G),I) = ed(N,J), pick(G,I - 1) if I > 1 .
	eq pick((ed(N,J),G),1) = ed(N,J) .
	eq pick((ed(N,J),empty),1) = ed(N,J) .
	
	--- list all existing Agents Id with an edge 
	op nodeEdge : Graph -> Set{Nat} .
	eq nodeEdge((ed(N,J),G)) = N, J, nodeEdge(G) .
	eq nodeEdge((ed(N,J), empty)) = N, J [owise] .
	
	op proBA : Graph Nat -> Float .
	eq proBA(G, N) = nodeDegre(G,N) / allNDegre(G,1) .
	
	op countFloat : Set{Nat} -> Float .
	eq countFloat((N, T)) = 1.0 + countFloat(T) .
	eq countFloat(empty) = 0.0 .
	
	op nodeDegre : Graph Nat -> Float .
	eq nodeDegre((ed(N,I),G),N) = 1.0 + nodeDegre(G,N) .
	eq nodeDegre((ed(J,I),G),N) = nodeDegre(G,N) .
	eq nodeDegre((ed(N,I),empty), N) = 1.0 .
	eq nodeDegre((ed(J,I),(empty).Graph), N) = 0.0 .
	
	op allNDegre : Graph Nat -> Float .
	eq allNDegre(G,N) = if N on G then nodeDegre(G,N) + allNDegre(G,N + 1) else 0.0 fi .
			
endfm 

view Graph from TRIV to NEEDED-SORT is
  sort Elt to Graph .
endv 

view Agent from TRIV to NEEDED-SORT is
  sort Elt to Agent .
endv
